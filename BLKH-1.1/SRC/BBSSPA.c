#include "BLKH.h"

/*
 * The BBSSPA function computes a lower bound for the asymmetric BTSP by 
 * solving the bottleneck biconnected spanning subgraph problem. 
 * At entry, it is assumed that the asymmetric BTSP has been converted into 
 * a symmetric instance. 
 * The function uses Hopcroft and Tarjan's algorithm for checking 
 * biconnectivity.
 * The search for optimum is governed by a threshold algorithm.
 * 
 * Time complexity: O(n^2), where n is the number of nodes.
 */

static void Recurse(Node * V);
static int Biconnected();

static int Delta;

int BBSSPA(int Low)
{
    int d, i, High = INT_MAX;
    Node *N;

    Delta = Low;
    if (Biconnected())
        return Low;
    Low++;
    while (Low < High) {
        Delta = Low + (High - Low) / 2;
        if (Biconnected()) {
            if (High == INT_MAX) {
                /* Compute Max as max{C[N][dad(N)]}, where dad(N) denotes 
                 * the dad of node N in the tree generated by the 
                 * Biconnected function */
                int Max = INT_MIN;
                for (N = &NodeSet[i = 1]; i <= Dimension; i++, N++)
                    if (N->Dad &&
                        (d = Distance(N, N->Dad)) > Max)
                        Max = d;
                if (Max < Delta)
                    Delta = Max;
            }
            High = Delta;
        } else
            Low = Delta + 1;
    }
    return Low;
}

static Node *CutNode, *W;
static int RootChildren, Visited;

#define Pre LastV
#define Low Rank

static int Biconnected()
{
    int i;

    for (i = 1; i <= Dimension; i++) {
        NodeSet[i].Pre = -1;
        NodeSet[i].Dad = 0;
    }
    Visited = RootChildren = 0;
    CutNode = 0;
    Recurse(FirstNode);
    if (CutNode || Visited < Dimension)
        return 0;
    return 1;
}

static void Recurse(Node * V)
{
    int i;
    V->Low = V->Pre = ++Visited;
    for (i = 1; i <= DimensionSaved; i++) {
        W = &NodeSet[V->Id > DimensionSaved ? i : DimensionSaved + i];
        if (W != V && W->Pre < V->Low && W != V->Dad &&
            Distance(V, W) <= Delta) {
            if (W->Pre == -1) {
                W->Dad = V;
                Recurse(W);
                W = &NodeSet[V->Id >
                             DimensionSaved ? i : DimensionSaved + i];
                if (V->Dad ? W->Low >= V->Pre : ++RootChildren > 1)
                    CutNode = V;
                if (CutNode)
                    return;;
                if (W->Low < V->Low)
                    V->Low = W->Low;
            } else
                V->Low = W->Pre;
        }
    }
}
