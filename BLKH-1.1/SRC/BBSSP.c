#include "BLKH.h"

/*
 * The BBSSP function computes a lower bound for the BTSP by solving the
 * bottleneck biconnected spanning subgraph problem. The function uses
 * Hopcroft and Tarjan's algorithm for checking biconnectivity. 
 * The search for optimum is governed by a threshold algorithm.
 *
 * If the BTSP is asymmetric, then the BBSSP solved for a symmetric relaxation
 * of the original cost matrix, C, where the relaxed cost of edge (i, j) is 
 * defined as the minimum of C[i][j] and C[j][i].
 *
 * Time complexity: O(n^2), where n is the number of nodes.
 */

static void Recurse(Node * V);
static int Biconnected();
static int min(int a, int b);

static int Delta;

int BBSSP(int Low)
{
    int d, i, High = INT_MAX;
    Node *N;

    Delta = Low;
    if (Biconnected())
        return Low;
    Low++;
    while (Low < High) {
        Delta = Low + (High - Low) / 2;
        if (Biconnected()) {
            if (High == INT_MAX) {
                /* Compute Max as max{C[N][dad(N)]}, where dad(N) denotes 
                   the dad of node N in the tree generated by the 
                   Biconnected function */ 
                int Max = INT_MIN;
                for (N = &NodeSet[i = 1]; i <= Dimension; i++, N++) 
                    if (N->Dad &&
                        (d = ProblemType != ATSP ? Distance(N, N->Dad) :
                             min(N->C[N->Dad->Id], N->Dad->C[i])) > Max)
                        Max = d;
                if (Max < Delta) 
                    Delta = Max; 
            }
            High = Delta;
        } else
            Low = Delta + 1;
    }
    return Low;
}

static Node *CutNode, *W;
static int RootChildren, Visited;

#define Pre LastV
#define Low Rank

static int Biconnected()
{
    int i;
    for (i = 1; i <= DimensionSaved; i++) {
        NodeSet[i].Pre = -1;
        NodeSet[i].Dad = 0;
    }
    Visited = RootChildren = 0;
    CutNode = 0;
    Recurse(FirstNode);
    if (CutNode || Visited < DimensionSaved)
        return 0;
    return 1;
}

static void Recurse(Node * V)
{
    int i;
    V->Low = V->Pre = ++Visited;
    for (i = 1; i <= DimensionSaved; i++) {
        W = &NodeSet[i];
        if (W != V && W->Pre < V->Low && W->Dad != V &&
            (ProblemType != ATSP ? 
             (!c || c(V, W) <= Delta) && Distance(V, W) <= Delta :
              min(V->C[i], W->C[V->Id]) <= Delta)) {
            if (W->Pre == -1) {
                W->Dad = V;
                Recurse(W);
                W = &NodeSet[i];
                if (V->Dad ? W->Low >= V->Pre : ++RootChildren > 1)
                    CutNode = V;
                if (CutNode)
                    return;
                if (W->Low < V->Low)
                    V->Low = W->Low;
            } else
                V->Low = W->Pre;
        }
    }
}

static int min(int a, int b)
{
    return a < b ? a : b;
}

